"""CVE vulnerability scanner."""

import json
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional

import httpx

from src.core.config import settings
from src.core.logger import get_logger
from src.core.models import Finding, Severity
from src.core.remote_executor import RemoteExecutor

logger = get_logger(__name__)


class CVEScanner:
    """CVE vulnerability scanner using NVD API."""

    def __init__(self, target: str = "localhost"):
        """Initialize the CVE scanner."""
        self.logger = get_logger(self.__class__.__name__)
        self.target = target
        self.executor = RemoteExecutor(target=target)
        self.nvd_api_key = settings.nvd_api_key
        self.cache_dir = settings.cve_cache_dir
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def scan_package(self, package_name: str, version: str) -> List[Finding]:
        """
        Scan a package for known CVEs.

        Args:
            package_name: Name of the package
            version: Version of the package

        Returns:
            List of findings
        """
        self.logger.info("Scanning package for CVEs", package=package_name, version=version)
        findings = []

        # Get CVEs for this package
        cves = self._get_cves_for_package(package_name, version)

        for cve_data in cves:
            finding = Finding(
                title=f"{cve_data['id']} - {package_name} {version}",
                description=cve_data.get("description", ""),
                severity=self._calculate_severity(cve_data),
                category="vulnerability",
                cve_id=cve_data["id"],
                cvss_score=cve_data.get("cvss_score"),
                recommendation=f"Update {package_name} to a patched version",
            )
            findings.append(finding)

        self.logger.info("Package scan completed", package=package_name, findings_count=len(findings))
        return findings

    def _get_cves_for_package(self, package_name: str, version: str) -> List[Dict]:
        """Get CVEs for a specific package and version."""
        # Check cache first
        cache_key = f"{package_name}_{version}.json"
        cache_file = self.cache_dir / cache_key

        if cache_file.exists():
            cache_age = datetime.now() - datetime.fromtimestamp(cache_file.stat().st_mtime)
            if cache_age < timedelta(hours=settings.cve_cache_ttl_hours):
                try:
                    with open(cache_file, "r") as f:
                        return json.load(f)
                except Exception as e:
                    self.logger.warning("Failed to load cache", error=str(e))

        # Query NVD API
        cves = self._query_nvd_api(package_name, version)

        # Cache results
        try:
            with open(cache_file, "w") as f:
                json.dump(cves, f)
        except Exception as e:
            self.logger.warning("Failed to cache results", error=str(e))

        return cves

    def _query_nvd_api(self, package_name: str, version: str) -> List[Dict]:
        """Query NVD API for CVEs."""
        # Note: NVD API requires rate limiting (5 requests per 30 seconds without API key)
        # With API key: 50 requests per 30 seconds

        try:
            headers = {}
            if self.nvd_api_key:
                headers["apiKey"] = self.nvd_api_key

            # Construct CPE string for the package
            # Format: cpe:2.3:a:vendor:product:version:*
            cpe_string = f"cpe:2.3:a:*:{package_name}:{version}:*"

            params = {
                "cpeName": cpe_string,
                "resultsPerPage": 20,
            }

            with httpx.Client(timeout=30.0) as client:
                response = client.get(self.base_url, headers=headers, params=params)
                response.raise_for_status()
                data = response.json()

                cves = []
                for item in data.get("vulnerabilities", []):
                    cve = item.get("cve", {})
                    cve_id = cve.get("id", "")
                    descriptions = cve.get("descriptions", [])
                    description = descriptions[0].get("value", "") if descriptions else ""

                    # Get CVSS score
                    cvss_score = None
                    metrics = cve.get("metrics", {})
                    if "cvssMetricV31" in metrics:
                        cvss_data = metrics["cvssMetricV31"][0]
                        cvss_score = cvss_data.get("cvssData", {}).get("baseScore")
                    elif "cvssMetricV30" in metrics:
                        cvss_data = metrics["cvssMetricV30"][0]
                        cvss_score = cvss_data.get("cvssData", {}).get("baseScore")
                    elif "cvssMetricV2" in metrics:
                        cvss_data = metrics["cvssMetricV2"][0]
                        cvss_score = cvss_data.get("cvssData", {}).get("baseScore")

                    cves.append(
                        {
                            "id": cve_id,
                            "description": description,
                            "cvss_score": cvss_score,
                        }
                    )

                # Rate limiting
                time.sleep(0.2)  # 5 requests per second max without API key

                return cves

        except httpx.HTTPError as e:
            self.logger.error("NVD API request failed", error=str(e))
            return []
        except Exception as e:
            self.logger.error("Unexpected error querying NVD API", error=str(e))
            return []

    def _calculate_severity(self, cve_data: Dict) -> Severity:
        """Calculate severity based on CVSS score."""
        cvss_score = cve_data.get("cvss_score")
        if cvss_score is None:
            return Severity.INFO

        if cvss_score >= 9.0:
            return Severity.CRITICAL
        elif cvss_score >= 7.0:
            return Severity.HIGH
        elif cvss_score >= 4.0:
            return Severity.MEDIUM
        elif cvss_score >= 0.1:
            return Severity.LOW
        else:
            return Severity.INFO

    def scan_system_packages(self) -> List[Finding]:
        """Scan all installed system packages for vulnerabilities."""
        self.logger.info("Scanning system packages for vulnerabilities")
        findings = []

        # Detect installed packages based on OS
        packages = self._get_installed_packages()

        for package_name, version in packages:
            package_findings = self.scan_package(package_name, version)
            findings.extend(package_findings)

        self.logger.info("System package scan completed", findings_count=len(findings))
        return findings

    def _get_installed_packages(self) -> List[tuple[str, str]]:
        """Get list of installed packages and versions."""
        packages = []

        # Try different package managers
        # Debian/Ubuntu
        stdout, stderr, returncode = self.executor.execute_command(
            ["dpkg-query", "-W", "-f=${Package} ${Version}\n"],
            timeout=10,
        )
        if returncode == 0 and stdout:
            for line in stdout.strip().split("\n"):
                if " " in line:
                    parts = line.split(" ", 1)
                    packages.append((parts[0], parts[1]))

        # RHEL/CentOS (if no Debian packages found)
        if not packages:
            stdout, stderr, returncode = self.executor.execute_command(
                ["rpm", "-qa", "--queryformat", "%{NAME} %{VERSION}\n"],
                timeout=10,
            )
            if returncode == 0 and stdout:
                for line in stdout.strip().split("\n"):
                    if " " in line:
                        parts = line.split(" ", 1)
                        packages.append((parts[0], parts[1]))

        return packages[:50]  # Limit to first 50 packages for demo purposes

